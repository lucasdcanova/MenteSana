import { useState, useRef, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { JournalEntry as JournalEntryType, InsertJournalEntry } from "@shared/schema";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { 
  Mic, 
  Loader2, 
  Brain, 
  FileAudio, 
  Sparkles, 
  History, 
  Text, 
  Send, 
  X,
  ChevronRight,
  Tag,
  Calendar,
  HeartPulse,
  Check
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { AnimatedButton } from "@/components/ui/animated-button";
import { BottomNavigation } from "@/components/layout/bottom-navigation";
import { formatDistanceToNow } from "date-fns";
import { ptBR } from "date-fns/locale";
import { Link } from "wouter";
import { m, AnimatePresence, LazyMotion, domAnimation } from "framer-motion";
import { 
  optimizedMotionProps, 
  ANIMATION_DURATIONS, 
  EASINGS, 
  listItem,
  staggerContainer,
  pressAnimation
} from "@/lib/animation-utils";

export default function JournalPage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  const [audioUrl, setAudioUrl] = useState<string | null>(null);
  const [showFeedback, setShowFeedback] = useState(false);
  const [processingFeedback, setProcessingFeedback] = useState(false);
  const [processingStep, setProcessingStep] = useState<string | null>(null);
  const [transcriberMood, setTranscriberMood] = useState<string>("neutro");
  const [showTextInput, setShowTextInput] = useState(false);
  const [textContent, setTextContent] = useState<string>("");
  const [mood, setMood] = useState<string>("neutro");
  
  // Impede o scroll da página
  useEffect(() => {
    document.body.style.overflow = 'hidden';
    
    // Restaura o scroll quando o componente for desmontado
    return () => {
      document.body.style.overflow = 'auto';
    };
  }, []);
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const timerRef = useRef<number | null>(null);
  
  // Fetch recent journal entries
  const { data: journalEntries = [] } = useQuery<JournalEntryType[]>({
    queryKey: ["/api/journal"],
    enabled: !!user,
  });
  
  // Sort entries by date (newest first)
  const recentEntries = [...journalEntries]
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
    .slice(0, 5);
  
  // Mutation para salvar entrada de texto
  const saveTextEntryMutation = useMutation({
    mutationFn: async ({ 
      userId, 
      text, 
      mood 
    }: { 
      userId: number;
      text: string; 
      mood: string;
    }) => {
      setProcessingFeedback(true);
      setProcessingStep("Processando sua nota...");
      
      // Criar a entrada no diário
      const journalEntry: InsertJournalEntry = {
        userId,
        content: text,
        mood
      };
      
      // Enviar para o endpoint de criação
      setProcessingStep("Analisando conteúdo emocional...");
      await new Promise(resolve => setTimeout(resolve, 500));
      
      setProcessingStep("Categorizando tópicos...");
      await new Promise(resolve => setTimeout(resolve, 500));
      
      setProcessingStep("Salvando no seu diário...");
      
      const res = await apiRequest("POST", "/api/journal", journalEntry);
      return await res.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/journal"] });
      
      toast({
        title: "Nota salva",
        description: "Sua anotação foi salva com sucesso."
      });
      
      // Limpar os estados
      setTextContent("");
      setShowTextInput(false);
      setProcessingFeedback(false);
      setProcessingStep(null);
      setShowFeedback(true);
      
      // Mostrar feedback de sucesso por 2 segundos
      setTimeout(() => {
        setShowFeedback(false);
      }, 2000);
    },
    onError: (error: Error) => {
      console.error("Erro ao salvar nota:", error);
      toast({
        title: "Erro ao salvar nota",
        description: error.message,
        variant: "destructive"
      });
      setProcessingFeedback(false);
      setProcessingStep(null);
    }
  });
  
  // Transcrição e análise de áudio mutation
  const transcribeAudioMutation = useMutation({
    mutationFn: async ({ 
      audioBlob, 
      userId, 
      mood,
      duration
    }: { 
      audioBlob: Blob;
      userId: number;
      mood: string;
      duration: number;
    }) => {
      setProcessingFeedback(true);
      setProcessingStep("Enviando gravação...");
      
      // Criar FormData para o upload
      const formData = new FormData();
      formData.append("audio", audioBlob, "journal-audio.wav");
      formData.append("mood", mood);
      formData.append("duration", String(duration));
      formData.append("autoTranscribe", "true"); // Ativa transcrição automática com OpenAI
      formData.append("autoCategories", "true"); // Ativa categorização automática
      
      // Enviar para o endpoint de transcrição
      setProcessingStep("Transcrevendo áudio...");
      const response = await apiRequest("POST", "/api/journal/transcribe", undefined, {
        body: formData
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Falha ao transcrever áudio");
      }
      
      setProcessingStep("Analisando conteúdo emocional...");
      await new Promise(resolve => setTimeout(resolve, 700));
      
      setProcessingStep("Categorizando tópicos...");
      await new Promise(resolve => setTimeout(resolve, 700));
      
      setProcessingStep("Identificando padrões de fala...");
      await new Promise(resolve => setTimeout(resolve, 500));
      
      setProcessingStep("Salvando no seu diário...");
      
      return await response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/journal"] });
      
      toast({
        title: "Nota de voz processada",
        description: data.category 
          ? `Seu áudio foi categorizado como "${data.category}"` 
          : "Seu áudio foi transcrito e salvo com sucesso."
      });
      
      // Limpar os estados
      setAudioBlob(null);
      setAudioUrl(null);
      setRecordingTime(0);
      setProcessingFeedback(false);
      setProcessingStep(null);
      setShowFeedback(true);
      
      // Mostrar feedback de sucesso por 2 segundos
      setTimeout(() => {
        setShowFeedback(false);
      }, 2000);
    },
    onError: (error: Error) => {
      console.error("Erro ao transcrever áudio:", error);
      toast({
        title: "Erro ao processar áudio",
        description: error.message,
        variant: "destructive"
      });
      setProcessingFeedback(false);
      setProcessingStep(null);
    }
  });

  // Limpar quando o componente for desmontado
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
      }
    };
  }, [audioUrl]);

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      audioChunksRef.current = [];
      
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunksRef.current.push(event.data);
        }
      };
      
      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });
        setAudioBlob(audioBlob);
        const url = URL.createObjectURL(audioBlob);
        setAudioUrl(url);
      };
      
      // Iniciar a gravação
      mediaRecorder.start();
      setIsRecording(true);
      setRecordingTime(0);
      setShowFeedback(false);
      
      // Iniciar o timer
      timerRef.current = window.setInterval(() => {
        setRecordingTime((prevTime) => prevTime + 1);
      }, 1000);
      
    } catch (error) {
      console.error("Erro ao iniciar a gravação:", error);
      toast({
        title: "Erro ao iniciar gravação",
        description: "Não foi possível acessar o microfone.",
        variant: "destructive"
      });
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
      
      // Parar o timer
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
      
      // Parar todas as faixas de áudio
      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
    }
  };

  const processRecording = () => {
    if (!user || !audioBlob) return;
    
    transcribeAudioMutation.mutateAsync({
      audioBlob,
      userId: user.id,
      mood: transcriberMood,
      duration: recordingTime
    });
  };

  const cancelRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
      
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    }
    
    setIsRecording(false);
    setAudioBlob(null);
    if (audioUrl) {
      URL.revokeObjectURL(audioUrl);
      setAudioUrl(null);
    }
    setRecordingTime(0);
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  };
  
  const toggleInputMode = () => {
    if (isRecording || audioUrl || processingFeedback) return;
    setShowTextInput(!showTextInput);
  };
  
  const saveTextEntry = () => {
    if (!user || !textContent.trim()) return;
    
    saveTextEntryMutation.mutateAsync({
      userId: user.id,
      text: textContent,
      mood: mood
    });
  };
  
  return (
    <div className="flex flex-col h-screen bg-[#f7f9f8] text-gray-800 overflow-hidden">
      <div className="flex-1 flex flex-col overflow-hidden pt-20">
        {/* Cabeçalho */}
        <div className="bg-white border-b fixed top-0 left-0 right-0 shadow-sm z-10">
          <div className="container mx-auto px-4 py-3 flex justify-between items-center">
            <div className="flex items-center space-x-2">
              <Brain className="h-5 w-5 text-[#4dbb8a]" />
              <h1 className="text-xl font-bold text-gray-800">Minhas Notas</h1>
            </div>
            
            <div className="flex items-center gap-2">
              {/* Botão para o histórico */}
              <Link href="/journal-history">
                <Button
                  variant="outline"
                  size="sm"
                  className="flex items-center gap-1 h-10 border-gray-200 text-gray-700"
                >
                  <History className="h-4 w-4" />
                  <span className="hidden sm:inline">Histórico</span>
                </Button>
              </Link>
              
              {/* Toggle entre voz e texto */}
              <Button
                variant="outline"
                size="sm"
                className="flex items-center gap-1 h-10 border-gray-200 text-gray-700"
                onClick={toggleInputMode}
                disabled={isRecording || !!audioUrl || processingFeedback}
              >
                {showTextInput ? 
                  <><Mic className="h-4 w-4" /><span className="hidden sm:inline">Voz</span></> : 
                  <><Text className="h-4 w-4" /><span className="hidden sm:inline">Texto</span></>
                }
              </Button>
              
              {/* Botão de Gravação */}
              {!showTextInput && (
                <button 
                  className={`
                    w-10 h-10 rounded-full flex items-center justify-center 
                    ${isRecording 
                      ? 'bg-red-500 text-white animate-pulse' 
                      : audioUrl 
                        ? 'bg-amber-500 text-white' 
                        : 'bg-[#4dbb8a] text-white'
                    }`}
                  onClick={isRecording ? stopRecording : startRecording}
                  disabled={!!audioUrl || transcribeAudioMutation.isPending || processingFeedback}
                >
                  <Mic className="h-5 w-5 text-white" />
                </button>
              )}
            </div>
          </div>
        </div>
        
        {/* Container para entrada de voz - centralizado na tela */}
        <AnimatePresence>
          <m.div 
            className="absolute left-0 right-0 top-[55%] transform -translate-y-1/2 px-4 z-10 mt-4"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ 
              duration: 0.35,
              ease: EASINGS.emphasis,
              delay: 0.2
            }}
            {...optimizedMotionProps}
          >
            <div className="relative max-w-xl mx-auto">
              <m.div 
                className="flex items-center bg-white p-3 rounded-full border border-gray-200 shadow-md"
                whileHover={{ 
                  boxShadow: "0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1)",
                  y: -2
                }}
                transition={{ 
                  type: "spring", 
                  stiffness: 500, 
                  damping: 30
                }}
                {...optimizedMotionProps}
              >
                <m.span 
                  className="flex-1 text-gray-400 text-sm ml-3"
                  animate={{ 
                    opacity: isRecording ? [0.7, 1, 0.7] : 1
                  }}
                  transition={{ 
                    repeat: isRecording ? Infinity : 0,
                    duration: isRecording ? 1.5 : 0
                  }}
                  {...optimizedMotionProps}
                >
                  {isRecording ? "Gravando..." : "Toque no microfone para começar a falar..."}
                </m.span>
                
                <m.button 
                  className={`ml-2 w-14 h-14 rounded-full flex items-center justify-center shadow-md hardware-accelerated ${
                    isRecording 
                      ? 'bg-red-600 hover:bg-red-700' 
                      : 'bg-[#4dbb8a] hover:bg-[#3b9e73]'
                  }`}
                  onClick={isRecording ? stopRecording : startRecording}
                  disabled={!!audioUrl || transcribeAudioMutation.isPending || processingFeedback}
                  whileTap={pressAnimation.whileTap}
                  animate={isRecording ? {
                    scale: [1, 1.05, 1],
                    boxShadow: [
                      "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
                      "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
                      "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)"
                    ]
                  } : {}}
                  transition={{ 
                    repeat: isRecording ? Infinity : 0, 
                    duration: isRecording ? 1.5 : 0.3,
                    ease: "easeInOut"
                  }}
                  {...optimizedMotionProps}
                >
                  <Mic className="h-6 w-6 text-white" />
                </m.button>
              </m.div>
            </div>
          </m.div>
        </AnimatePresence>
        
        {/* Container para texto */}
        {showTextInput && !isRecording && !audioUrl && !processingFeedback && (
          <div className="absolute left-0 right-0 top-[55%] transform -translate-y-1/2 z-10 px-4">
            <div className="relative max-w-xl mx-auto">
              <div className="bg-white rounded-lg p-4 border border-gray-200 shadow-md">
                <div className="flex flex-col space-y-3">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Como você está se sentindo?
                    </label>
                    <div className="flex flex-wrap gap-2">
                      {["alegre", "triste", "ansioso", "estressado", "neutro", "motivado", "cansado", "calmo"].map((moodOption) => (
                        <button
                          key={moodOption}
                          type="button"
                          onClick={() => setMood(moodOption)}
                          className={`px-3 py-1 rounded-full text-xs ${
                            mood === moodOption
                              ? "bg-[#4dbb8a] text-white"
                              : "bg-gray-100 text-gray-700 hover:bg-gray-200"
                          }`}
                        >
                          {moodOption.charAt(0).toUpperCase() + moodOption.slice(1)}
                        </button>
                      ))}
                    </div>
                  </div>
                  
                  <div>
                    <label htmlFor="text-content" className="block text-sm font-medium text-gray-700 mb-1">
                      O que você está pensando?
                    </label>
                    <Textarea
                      id="text-content"
                      value={textContent}
                      onChange={(e) => setTextContent(e.target.value)}
                      placeholder="Escreva aqui seus pensamentos, sentimentos ou experiências..."
                      className="w-full min-h-[120px] border-gray-200 focus:border-[#4dbb8a] focus:ring-[#4dbb8a]"
                    />
                  </div>
                  
                  <div className="flex justify-end space-x-2 pt-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => {
                        setShowTextInput(false);
                        setTextContent("");
                      }}
                      className="border-gray-200 text-gray-700"
                    >
                      Cancelar
                    </Button>
                    <Button
                      size="sm"
                      onClick={saveTextEntry}
                      className="bg-[#4dbb8a] hover:bg-[#3b9e73] text-white"
                      disabled={!textContent.trim() || saveTextEntryMutation.isPending}
                    >
                      {saveTextEntryMutation.isPending ? (
                        <>
                          <Loader2 className="mr-1 h-3 w-3 animate-spin" />
                          Salvando...
                        </>
                      ) : "Salvar nota"}
                    </Button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}
        
        {/* Área principal com design iOS-style */}
        <LazyMotion features={domAnimation}>
          <div className="flex-1 p-4 flex flex-col items-center justify-start overflow-hidden">
            {/* Avatar e saudação */}
            <m.div 
              className="flex flex-col items-center mt-16 mb-12 w-full max-w-md"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, ease: "easeOut" }}
            >
              <m.div 
                className="w-20 h-20 bg-[#4dbb8a] rounded-full overflow-hidden mb-5 shadow-md"
                whileHover={{ scale: 1.05 }}
                transition={{ type: "spring", stiffness: 400, damping: 10 }}
              >
                {user?.profilePicture ? (
                  <img 
                    src={user.profilePicture} 
                    alt={user.firstName} 
                    className="w-full h-full object-cover" 
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center bg-[#4dbb8a] text-white text-2xl font-bold">
                    {user?.firstName?.[0] || 'U'}
                  </div>
                )}
              </m.div>
              
              <div className="text-center">
                <m.h1 
                  className="text-2xl font-bold text-gray-800"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: 0.1, duration: 0.3 }}
                >
                  Olá {user?.firstName || 'você'},
                </m.h1>
                <m.h2 
                  className="text-xl font-bold mb-2 text-gray-800"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: 0.2, duration: 0.3 }}
                >
                  o que está passando pela sua cabeça hoje?
                </m.h2>
                
                <m.p 
                  className="text-sm text-gray-600 mt-2 px-4"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: 0.3, duration: 0.3 }}
                >
                  {showTextInput ? 
                    "Escreva seus pensamentos e sentimentos para registro e análise" : 
                    "Grave sua nota de voz e a IA irá transcrever e categorizar automaticamente"
                  }
                </m.p>
              </div>
            </m.div>
            
            {/* Feedback de processamento com animações suaves do iOS */}
            {processingFeedback && (
              <m.div 
                className="mt-3 mb-2 text-center flex flex-col items-center"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                transition={{ duration: 0.3, ease: "easeOut" }}
              >
                <m.div 
                  className="mb-2.5 p-2 rounded-full bg-[#e9fbf2] shadow-sm"
                  animate={{ 
                    scale: [1, 1.1, 1],
                    rotate: [0, 10, 0, -10, 0]
                  }}
                  transition={{ 
                    duration: 2,
                    repeat: Infinity,
                    ease: "easeInOut"
                  }}
                >
                  <Loader2 className="h-6 w-6 text-[#4dbb8a] animate-spin" />
                </m.div>
                <m.p 
                  className="text-sm text-[#4dbb8a] font-medium mb-1"
                  animate={{ opacity: [0.7, 1, 0.7] }}
                  transition={{ duration: 1.5, repeat: Infinity }}
                >
                  {processingStep}
                </m.p>
                <p className="text-xs text-gray-500">Estamos processando sua entrada...</p>
              </m.div>
            )}
            
            {/* Feedback de gravação bem-sucedida com animações */}
            {showFeedback && !processingFeedback && (
              <m.div 
                className="mt-3 mb-2 text-center flex flex-col items-center"
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                transition={{ duration: 0.3, ease: "easeOut" }}
              >
                <m.div 
                  className="mb-2 p-2 rounded-full bg-[#e9fbf2] shadow-sm"
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  transition={{ 
                    type: "spring",
                    stiffness: 260,
                    damping: 20 
                  }}
                >
                  <Sparkles className="h-5 w-5 text-[#4dbb8a]" />
                </m.div>
                <m.p 
                  className="text-sm text-[#4dbb8a] font-medium mb-1"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: 0.1 }}
                >
                  Nota salva com sucesso!
                </m.p>
                <m.p 
                  className="text-xs text-gray-500 max-w-xs text-center"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: 0.2 }}
                >
                  Seu conteúdo foi analisado, categorizado e armazenado
                </m.p>
              </m.div>
            )}
            
            {/* Histórico de diário recente com design iOS card-style */}
            {!isRecording && !audioUrl && !processingFeedback && !showFeedback && recentEntries.length > 0 && (
              <m.div 
                className="mt-5 space-y-2.5 w-full max-w-md"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ 
                  duration: 0.4, 
                  ease: "easeOut",
                  staggerChildren: 0.1
                }}
              >
                <div className="flex items-center justify-between mb-2">
                  <h3 className="text-[#4dbb8a] font-medium text-sm">Registros recentes</h3>
                  <Link href="/journal-history">
                    <Button 
                      variant="ghost" 
                      size="sm"
                      className="h-8 text-xs text-[#4dbb8a] hover:bg-[#e9fbf2] hover:text-[#3b9e73]"
                    >
                      Ver histórico <ChevronRight className="h-3 w-3 ml-0.5" />
                    </Button>
                  </Link>
                </div>
                
                <m.div className="space-y-2.5" variants={staggerContainer}>
                  {recentEntries.slice(0, 3).map(entry => (
                    <m.div 
                      key={entry.id} 
                      className="bg-white rounded-xl p-3.5 border border-gray-100 shadow-sm hover:shadow-md transition-shadow"
                      variants={listItem}
                      whileHover={{ y: -2, transition: { duration: 0.2 } }}
                    >
                      <div className="flex justify-between items-start mb-1.5">
                        <div className="flex items-center text-xs text-gray-500">
                          <Calendar className="h-3 w-3 mr-1 text-gray-400" />
                          {formatDistanceToNow(new Date(entry.date), { locale: ptBR, addSuffix: true })}
                        </div>
                        <div className="flex">
                          {entry.mood && (
                            <div className="ml-1 px-2 py-0.5 rounded-full bg-[#e9fbf2] text-[#4dbb8a] text-xs flex items-center">
                              <HeartPulse className="h-3 w-3 mr-1" />
                              {entry.mood}
                            </div>
                          )}
                          {entry.category && (
                            <div className="ml-1 px-2 py-0.5 rounded-full bg-[#f0f0f0] text-gray-600 text-xs flex items-center">
                              <Tag className="h-3 w-3 mr-1" />
                              {entry.category}
                            </div>
                          )}
                        </div>
                      </div>
                      <p className="mb-1.5 text-gray-800 text-sm leading-snug">{entry.content}</p>
                      {entry.audioUrl && (
                        <div className="mt-2 bg-gray-50 rounded-md p-1.5">
                          <audio src={entry.audioUrl} controls className="w-full h-7" />
                        </div>
                      )}
                      {entry.tags && entry.tags.length > 0 && (
                        <div className="flex flex-wrap gap-1 mt-2">
                          {entry.tags.map(tag => (
                            <Badge key={tag} variant="secondary" className="text-[10px] px-1.5 py-0 h-5 bg-gray-100 text-gray-600">
                              {tag}
                            </Badge>
                          ))}
                        </div>
                      )}
                    </m.div>
                  ))}
                </m.div>
              </m.div>
            )}
            
            {/* Área de gravação atual com animações de pulsação do iOS */}
            {isRecording && (
              <m.div 
                className="mt-3 flex flex-col items-center justify-center mb-3"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                transition={{ duration: 0.3 }}
              >
                <div className="text-center">
                  <m.div 
                    className="flex items-center justify-center h-24 w-24 rounded-full bg-[#e9fbf2] mb-3 shadow-md mx-auto"
                    animate={{ 
                      scale: [1, 1.05, 1],
                      boxShadow: [
                        "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
                        "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
                        "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)"
                      ]
                    }}
                    transition={{ 
                      repeat: Infinity,
                      duration: 1.5,
                      ease: "easeInOut" 
                    }}
                  >
                    <m.div
                      animate={{ scale: [1, 1.2, 1] }}
                      transition={{ repeat: Infinity, duration: 1.5 }}
                    >
                      <Mic className="h-10 w-10 text-red-500" />
                    </m.div>
                  </m.div>
                  <m.p 
                    className="text-3xl font-bold mb-2 text-gray-800"
                    animate={{ opacity: [0.8, 1, 0.8] }}
                    transition={{ repeat: Infinity, duration: 2 }}
                  >
                    {formatTime(recordingTime)}
                  </m.p>
                  <p className="text-sm text-gray-600 mb-1.5">Gravando sua nota de voz...</p>
                  <p className="text-xs text-gray-500">Toque no botão do microfone novamente para parar</p>
                </div>
              </m.div>
            )}
            
            {/* Preview de áudio com visual do iOS */}
            {audioUrl && !isRecording && (
              <m.div 
                className="mt-3 my-2 w-full max-w-md"
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.3 }}
              >
                <div className="bg-white rounded-xl p-5 border border-gray-100 shadow-md">
                  <div className="flex items-center justify-center mb-4 text-gray-800">
                    <div className="p-2.5 bg-[#e9fbf2] rounded-full mr-3">
                      <FileAudio className="h-5 w-5 text-[#4dbb8a]" />
                    </div>
                    <span className="text-lg font-medium">Revisar áudio</span>
                  </div>
                  
                  <div className="bg-gray-50 rounded-xl p-3 mb-4">
                    <audio src={audioUrl} controls className="w-full mb-2" />
                    <div className="flex justify-between items-center">
                      <span className="text-xs text-gray-500">
                        Duração: {formatTime(recordingTime)}
                      </span>
                      <span className="text-xs text-[#4dbb8a]">
                        Pronto para transcrição automática
                      </span>
                    </div>
                  </div>
                  
                  <div className="flex gap-3">
                    <Button 
                      onClick={cancelRecording}
                      variant="outline" 
                      size="sm"
                      className="flex-1 border-gray-200 text-gray-700 hover:bg-gray-50 font-medium"
                    >
                      <X className="h-4 w-4 mr-1.5" />
                      Descartar
                    </Button>
                    <Button 
                      onClick={processRecording}
                      size="lg"
                      className="flex-1 bg-[#4dbb8a] hover:bg-[#3b9e73] text-white font-medium text-sm"
                      disabled={transcribeAudioMutation.isPending}
                    >
                      {transcribeAudioMutation.isPending ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Processando...
                        </>
                      ) : (
                        <>
                          <Check className="mr-1.5 h-4 w-4" />
                          Salvar e transcrever
                        </>
                      )}
                    </Button>
                  </div>
                </div>
              </m.div>
            )}
          </div>
        </LazyMotion>
      </div>
      
      <BottomNavigation />
    </div>
  );
}
